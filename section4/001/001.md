## 문제

자릿수의 합
N개의 자연수가 입력되면 각 자연수의 자릿수의 합을 구하고, 그 합이 최대인 자연수를 출력
하는 프로그램을 작성하세요. 자릿수의 합이 같은 경우 원래 숫자가 큰 숫자를 답으로 합니다.
만약 235 와 1234가 동시에 답이 될 수 있다면 1234를 답으로 출력해야 합니다.
▣ 입력설명
첫 줄에 자연수의 개수 N(3<=N<=100)이 주어지고, 그 다음 줄에 N개의 자연수가 주어진다.
각 자연수의 크기는 10,000,000를 넘지 않는다.
▣ 출력설명
자릿수의 합이 최대인 자연수를 출력한다.
▣ 입력예제 1
7
128 460 603 40 521 137 123
▣ 출력예제 1
137

## 1차 풀이

```javascript
function solution(arr) {
  const sumArr = arr.map((num) => {
    const stringNum = num.toString();

    return [...stringNum].reduce((acc, char) => {
      return acc + Number(char);
    }, 0);
  });
  console.log(sumArr);

  let maxNum = Number.MIN_SAFE_INTEGER;
  let maxIdx;
  sumArr.forEach((num, i) => {
    if (num > maxNum) {
      maxNum = num;
      maxIdx = i;
    }
    if (num === maxNum) {
      if (arr[maxIdx] < arr[i]) maxIdx = i;
    }
  });

  return arr[maxIdx];
}
```

## 2차 풀이

1-pass로 풀어봤다.
기존에는 모든 자릿수의 합을 구한 배열을 다시 Math.max(...arr)을 이용해 다시 비교했디.
하지만 2차 풀이에서는 한번의 순회에서 최대 자릿수 합을 업데이트하고, 그때의 숫자를 업데이트하며 순회한다.
그리고 각 자릿수의 합도 타입변환 없이 숫자타입으로만 계산한다.

이때 아래의 과정을 tempNum이 0이 아닐때까지 반복한다.

1. 현재 숫자에 10의 나머지가 숫자의 1의 자리 숫자를 추출해 각 숫자 합변수에 중첩
2. 이때마다 10의 몫을 새로 업데이트해 줄인다.

그리고 만약 현재 숫자 합과 최대 합이 같다면 실제 숫자끼리 추가로 비교해준다.

```javascript
function solution(arr) {
  let maxSumNum = Number.MIN_SAFE_INTEGER;
  let res;
  for (const num of arr) {
    let tempNum = num;
    let curSum = 0;
    while (tempNum !== 0) {
      curSum += tempNum % 10;
      tempNum = Math.floor(tempNum / 10);
    }
    if (maxSumNum < curSum) {
      res = num;
      maxSumNum = curSum;
    } else if (maxSumNum === curSum) {
      if (res < num) {
        res = num;
      }
    }

    console.log(curSum, num);
  }

  return res;
}
```
