## 문제

가장 짧은 문자거리
한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출
력하는 프로그램을 작성하세요.
▣ 입력설명
첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다.
문자열의 길이는 100을 넘지 않는다.
▣ 출력설명
첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.
▣ 입력예제 1
teachermode e
▣ 출력예제 1
1 0 1 2 1 0 1 2 2 1 0

## 1차 풀이

문자열의 각 문자idx를 기준으로 매번 문자열 전체를 다시 탐색하며 모든 t의 위치를 찾아 거리른 잰뒤, 인덱스 거리 차의 최솟값을 반환한다.

이 설계의 비용은 O(N^2).... 경우의 수가 100만이 된다면...?

```javascript
function solution(s, t) {
  const arr = s.split("");
  return arr.map((char, idx) => {
    let pos = 0;
    const distanceArr = [];
    while (arr.indexOf(t, pos) !== -1) {
      const newPos = arr.indexOf(t, pos);
      let dis = idx - newPos < 0 ? -1 * (idx - newPos) : idx - newPos;
      distanceArr.push(dis);
      pos = newPos + 1;
    }
    return Math.min(...distanceArr);
  });
}
```

## 2차 풀이

1차 풀이에서 계속해서 2차 루프에서 구한 t의 거리들을 재사용하지 않고 버리고, 루프마다 새롭게 찾는다... 비효율이 존재한다.
2-pass 알고리즘을 공부해서 다시 설계하는데 영향을 받았다.
현재 문제를 다시 깔끔하게 파악하자.
문자열에서 t에 대한 각 문자와의 거리를 구해야한다.
각 요소에 대한 t와의 거리는 두가지의 방향이 존재한다.
왼쪽에 t가 있는경우 , 오른쪽에 t가 있는경우.

생각의 흐름대로 시각화 해보자.
_._,t,_,_,t,\_ 이렇게 있다고 가정한다.

1. 왼쪽에 있는 t를 찾는경우 -> ?,?,0,1,2,0,1 이와같이 거리들을 표현할 수 있다. ? 는 왼쪽에 t가 없어서 일단 보류.
2. 오른쪽에서 t를 찾는경우 -> 2,1,0,2,1,0,?
   이때 패턴을 찾을 수 있다. 점점 거리가 멀어질 수록 이전의 거리에 +1 이 더해진다.

1과 2 두개의 배열을 합쳐야한다. 기준은 두 동일한 인덱스의 요소중에 제일 작은 값으로 넣는다.
이제 그러면 제일 인접한 t의 거리 배열이 반환된다.

비교할때 최소값을 비교하기에, ? 로 보류한 값은 비교에 영향이 가지않게 최댓값으로 삽입한다. -> 최초 dis는 최댓값으로 초기화.
그리고 t를 만나면 0으로 dis를 초기화하고, t가 아니면 기존의 dis에 1씩 더한다.

```javascript
function solution(s, t) {
  let distance = Number.MAX_SAFE_INTEGER;
  const arr = [...s];
  //왼쪽 기준
  const posArr = arr.map((char) => {
    if (char === t) {
      distance = 0;
      return distance;
    }
    distance += 1;
    return distance;
  });

  distance = Number.MAX_SAFE_INTEGER;
  //오른쪽 기준 순회하며 기존의 거리와 비교
  for (let i = arr.length - 1; i >= 0; i--) {
    if (arr[i] === t) {
      distance = 0;
    } else {
      distance += 1;
    }

    posArr[i] = Math.min(distance, posArr[i]);
  }

  return posArr;
}
```
