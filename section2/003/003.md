## 문제

가위 바위 보
A, B 두 사람이 가위바위보 게임을 합니다. 총 N번의 게임을 하여 A가 이기면 A를 출력하고,
B가 이기면 B를 출력합니다. 비길 경우에는 D를 출력합니다.
가위, 바위, 보의 정보는 1:가위, 2:바위, 3:보로 정하겠습니다.
예를 들어 N=5이면
회수 1 2 3 4 5
A의 정보 2 3 3 1 3
B의 정보 1 1 2 2 3
승자 A B A B D
두 사람의 각 회의 가위, 바위, 보 정보가 주어지면 각 회를 누가 이겼는지 출력하는 프로그램
을 작성하세요.
▣ 입력설명
첫 번째 줄에 게임 횟수인 자연수 N(1<=N<=100)이 주어집니다.
두 번째 줄에는 A가 낸 가위, 바위, 보 정보가 N개 주어집니다.
세 번째 줄에는 B가 낸 가위, 바위, 보 정보가 N개 주어집니다.
▣ 출력설명
각 줄에 각 회의 승자를 출력합니다. 비겼을 경우는 D를 출력합니다.
▣ 입력예제 1
5
2 3 3 1 3
1 1 2 2 3
▣ 출력예제 1
A
B
A
B
D

## 1차 풀이

각 상황에 맞는 족보 함수를 만들어서 A와B의 입력값을 전달해 결과를 받음. 근데 이게 최선일까...?

```javascript
function solution(a, b) {
  const jokbo = {
    si: (b) => {
      switch (b) {
        case "si":
          return "D";
        case "ro":
          return "B";
        case "pa":
          return "A";
      }
    },
    ro: (b) => {
      switch (b) {
        case "si":
          return "A";
        case "ro":
          return "D";
        case "pa":
          return "B";
      }
    },
    pa: (b) => {
      switch (b) {
        case "si":
          return "B";
        case "ro":
          return "A";
        case "pa":
          return "D";
      }
    },
  };
  const arr = ["", "si", "ro", "pa"];

  return a.map((el, idx) => {
    const currentA = arr[el];
    const currentB = arr[b[idx]];

    return jokbo[currentA](currentB);
  });
}
```

## 2차 풀이

결과에 집중하자. **각회의 승자**출력...
이때 두사람의 입장을 모두 생각하지 말고 **A가 이기는 경우에만** 생각해보자.
그리고 비기는 case도 생각한다.
그러면 나머지는 모두 B가 이기는 걸로 좁힐 수 있다.

### 정리

너무 양쪽의 케이스를 방대하게 생각하지말고, 우선 결과를 단순화한다. -> 결과값 출력.
두사람 모두 생각하지 말고 한사람만 픽해서 생각하자. -> A가 이기는 케이스만 생각하자.
그러면 비기는 케이스는 단순하므로 설정하면 나머지는 모두 B가 이긴다.

-->**분류문제를 풀때는 특정 부분을 기준 잡고 생각해야 한다.**

```javascript
function solution(a, b) {
  return a.map((A, idx) => {
    const B = b[idx];
    if (A === 1 && B === 3) return "A";
    if (A === 2 && B === 1) return "A";
    if (A === 3 && B === 2) return "A";
    if (A === B) return "D";
    return "B";
  });
}
```
